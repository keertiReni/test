//
//  SalesConfigControls.swift
//  ProjectName
//
//  Created by Systems Usability on 26/05/2017.
//  Copyright Â© 2017 Renishaw. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class SalesConfigControls : NSObject {
    
    //// Cache
    
    private struct Cache {
        static let onyxDefault: UIColor = UIColor(red: 0.902, green: 0.902, blue: 0.902, alpha: 1.000)
        static let onyxGreen: UIColor = UIColor(red: 0.498, green: 0.890, blue: 0.192, alpha: 1.000)
        static let onyxErrorRed: UIColor = UIColor(red: 0.988, green: 0.284, blue: 0.354, alpha: 1.000)
        static let onyxSelectedColour: UIColor = UIColor(red: 1.000, green: 0.651, blue: 0.259, alpha: 1.000)
        static let onyxOrange: UIColor = UIColor(red: 1.000, green: 0.600, blue: 0.200, alpha: 1.000)
    }
    
    //// Colors
    
    @objc public dynamic class var onyxDefault: UIColor { return Cache.onyxDefault }
    @objc public dynamic class var onyxGreen: UIColor { return Cache.onyxGreen }
    @objc public dynamic class var onyxErrorRed: UIColor { return Cache.onyxErrorRed }
    @objc public dynamic class var onyxSelectedColour: UIColor { return Cache.onyxSelectedColour }
    @objc public dynamic class var onyxOrange: UIColor { return Cache.onyxOrange }
    
    //// Drawing Methods
    
    @objc public dynamic class func drawMagnifyGlassIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// Group
        //// Rectangle Drawing
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.40625 * group.width, y: group.minY + 0.53125 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.20937 * group.width, y: group.minY + 0.72500 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.26875 * group.width, y: group.minY + 0.78125 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.46562 * group.width, y: group.minY + 0.58750 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.72812 * group.width, y: group.minY + 0.56250 * group.height), controlPoint1: CGPoint(x: group.minX + 0.54375 * group.width, y: group.minY + 0.64062 * group.height), controlPoint2: CGPoint(x: group.minX + 0.65625 * group.width, y: group.minY + 0.63437 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.72812 * group.width, y: group.minY + 0.26562 * group.height), controlPoint1: CGPoint(x: group.minX + 0.80625 * group.width, y: group.minY + 0.47812 * group.height), controlPoint2: CGPoint(x: group.minX + 0.81250 * group.width, y: group.minY + 0.34687 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.43125 * group.width, y: group.minY + 0.26562 * group.height), controlPoint1: CGPoint(x: group.minX + 0.64375 * group.width, y: group.minY + 0.18437 * group.height), controlPoint2: CGPoint(x: group.minX + 0.51250 * group.width, y: group.minY + 0.18750 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.40625 * group.width, y: group.minY + 0.53125 * group.height), controlPoint1: CGPoint(x: group.minX + 0.36250 * group.width, y: group.minY + 0.34062 * group.height), controlPoint2: CGPoint(x: group.minX + 0.35313 * group.width, y: group.minY + 0.44687 * group.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: group.minX + 0.49375 * group.width, y: group.minY + 0.32812 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.66875 * group.width, y: group.minY + 0.32812 * group.height), controlPoint1: CGPoint(x: group.minX + 0.54063 * group.width, y: group.minY + 0.27812 * group.height), controlPoint2: CGPoint(x: group.minX + 0.61875 * group.width, y: group.minY + 0.28125 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.66875 * group.width, y: group.minY + 0.50312 * group.height), controlPoint1: CGPoint(x: group.minX + 0.71875 * group.width, y: group.minY + 0.37500 * group.height), controlPoint2: CGPoint(x: group.minX + 0.71562 * group.width, y: group.minY + 0.45312 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.49375 * group.width, y: group.minY + 0.50312 * group.height), controlPoint1: CGPoint(x: group.minX + 0.62187 * group.width, y: group.minY + 0.55312 * group.height), controlPoint2: CGPoint(x: group.minX + 0.54375 * group.width, y: group.minY + 0.55312 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.49375 * group.width, y: group.minY + 0.32812 * group.height), controlPoint1: CGPoint(x: group.minX + 0.44375 * group.width, y: group.minY + 0.45312 * group.height), controlPoint2: CGPoint(x: group.minX + 0.45000 * group.width, y: group.minY + 0.37812 * group.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
    }
    
    @objc public dynamic class func drawDeleteIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let deletesvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// Delete.svg Group
        //// Rectangle Drawing
        
        
        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: deletesvgGroup.minX + 0.31680 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.38969 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.31680 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.46000 * deletesvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: deletesvgGroup.minX + 0.35781 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height), controlPoint1: CGPoint(x: deletesvgGroup.minX + 0.31680 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.48250 * deletesvgGroup.height), controlPoint2: CGPoint(x: deletesvgGroup.minX + 0.33594 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.35234 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.35234 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.70188 * deletesvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: deletesvgGroup.minX + 0.45078 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.80312 * deletesvgGroup.height), controlPoint1: CGPoint(x: deletesvgGroup.minX + 0.35234 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.75813 * deletesvgGroup.height), controlPoint2: CGPoint(x: deletesvgGroup.minX + 0.39609 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.80312 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.56016 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.80312 * deletesvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: deletesvgGroup.minX + 0.64492 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.71594 * deletesvgGroup.height), controlPoint1: CGPoint(x: deletesvgGroup.minX + 0.60664 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.80312 * deletesvgGroup.height), controlPoint2: CGPoint(x: deletesvgGroup.minX + 0.64492 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.76375 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.64492 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.63945 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: deletesvgGroup.minX + 0.68047 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.46000 * deletesvgGroup.height), controlPoint1: CGPoint(x: deletesvgGroup.minX + 0.66133 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height), controlPoint2: CGPoint(x: deletesvgGroup.minX + 0.68047 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.48250 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.68047 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.38969 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.31680 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.38969 * deletesvgGroup.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: deletesvgGroup.minX + 0.46445 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.69062 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.42891 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.69062 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.42891 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.46445 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.46445 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.69062 * deletesvgGroup.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: deletesvgGroup.minX + 0.57383 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.69062 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.53828 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.69062 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.53828 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.57383 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.50219 * deletesvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.57383 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.69062 * deletesvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: deletesvgGroup.minX + 0.60938 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31375 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.60938 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.28000 * deletesvgGroup.height))
        bezier2Path.addCurve(to: CGPoint(x: deletesvgGroup.minX + 0.57109 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.24062 * deletesvgGroup.height), controlPoint1: CGPoint(x: deletesvgGroup.minX + 0.60938 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.25750 * deletesvgGroup.height), controlPoint2: CGPoint(x: deletesvgGroup.minX + 0.59297 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.24062 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.42891 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.24062 * deletesvgGroup.height))
        bezier2Path.addCurve(to: CGPoint(x: deletesvgGroup.minX + 0.39063 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.28000 * deletesvgGroup.height), controlPoint1: CGPoint(x: deletesvgGroup.minX + 0.40703 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.24062 * deletesvgGroup.height), controlPoint2: CGPoint(x: deletesvgGroup.minX + 0.39063 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.25750 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.39063 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31656 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.28125 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31656 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.28125 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.35312 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.71875 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.35312 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.71875 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31375 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.60938 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31375 * deletesvgGroup.height))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: deletesvgGroup.minX + 0.42617 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31375 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.42617 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.27719 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.57109 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.27719 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.57109 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31375 * deletesvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: deletesvgGroup.minX + 0.42617 * deletesvgGroup.width, y: deletesvgGroup.minY + 0.31375 * deletesvgGroup.height))
        bezier2Path.close()
        SalesConfigControls.onyxDefault.setFill()
        bezier2Path.fill()
    }
    
    @objc public dynamic class func drawSendIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let sendsvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// Send.svg Group
        //// Rectangle Drawing
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: sendsvgGroup.minX + 0.16875 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.75000 * sendsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: sendsvgGroup.minX + 0.16875 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.75000 * sendsvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: sendsvgGroup.minX + 0.54063 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.37500 * sendsvgGroup.height), controlPoint1: CGPoint(x: sendsvgGroup.minX + 0.18750 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.55625 * sendsvgGroup.height), controlPoint2: CGPoint(x: sendsvgGroup.minX + 0.34688 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.38750 * sendsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: sendsvgGroup.minX + 0.54063 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.25000 * sendsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: sendsvgGroup.minX + 0.79063 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.41562 * sendsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: sendsvgGroup.minX + 0.54063 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.58125 * sendsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: sendsvgGroup.minX + 0.54063 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.45625 * sendsvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: sendsvgGroup.minX + 0.16875 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.75000 * sendsvgGroup.height), controlPoint1: CGPoint(x: sendsvgGroup.minX + 0.39375 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.46875 * sendsvgGroup.height), controlPoint2: CGPoint(x: sendsvgGroup.minX + 0.18750 * sendsvgGroup.width, y: sendsvgGroup.minY + 0.60000 * sendsvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
    }
    
    @objc public dynamic class func drawListIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        
        //// Subframes
        let dROsvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// DRO.svg Group
        //// Rectangle Drawing
        
        
        //// Group 3
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRect(x: dROsvgGroup.minX + fastFloor(dROsvgGroup.width * 0.37500 + 0.5), y: dROsvgGroup.minY + fastFloor(dROsvgGroup.height * 0.25000 + 0.5), width: fastFloor(dROsvgGroup.width * 0.79063 + 0.2) - fastFloor(dROsvgGroup.width * 0.37500 + 0.5) + 0.3, height: fastFloor(dROsvgGroup.height * 0.33437 - 0.2) - fastFloor(dROsvgGroup.height * 0.25000 + 0.5) + 0.7))
        SalesConfigControls.onyxDefault.setFill()
        rectangle2Path.fill()
        
        
        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(rect: CGRect(x: dROsvgGroup.minX + fastFloor(dROsvgGroup.width * 0.37500 + 0.5), y: dROsvgGroup.minY + fastFloor(dROsvgGroup.height * 0.45625 - 0.1) + 0.6, width: fastFloor(dROsvgGroup.width * 0.79063 + 0.2) - fastFloor(dROsvgGroup.width * 0.37500 + 0.5) + 0.3, height: fastFloor(dROsvgGroup.height * 0.54063 + 0.2) - fastFloor(dROsvgGroup.height * 0.45625 - 0.1) - 0.3))
        SalesConfigControls.onyxDefault.setFill()
        rectangle3Path.fill()
        
        
        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: dROsvgGroup.minX + fastFloor(dROsvgGroup.width * 0.37500 + 0.5), y: dROsvgGroup.minY + fastFloor(dROsvgGroup.height * 0.66563 + 0.2) + 0.3, width: fastFloor(dROsvgGroup.width * 0.79063 + 0.2) - fastFloor(dROsvgGroup.width * 0.37500 + 0.5) + 0.3, height: fastFloor(dROsvgGroup.height * 0.75000 + 0.5) - fastFloor(dROsvgGroup.height * 0.66563 + 0.2) - 0.3))
        SalesConfigControls.onyxDefault.setFill()
        rectangle4Path.fill()
        
        
        //// Rectangle 5 Drawing
        let rectangle5Path = UIBezierPath(rect: CGRect(x: dROsvgGroup.minX + fastFloor(dROsvgGroup.width * 0.20938 - 0.2) + 0.7, y: dROsvgGroup.minY + fastFloor(dROsvgGroup.height * 0.25000 + 0.5), width: fastFloor(dROsvgGroup.width * 0.29375 + 0.1) - fastFloor(dROsvgGroup.width * 0.20938 - 0.2) - 0.3, height: fastFloor(dROsvgGroup.height * 0.33437 - 0.2) - fastFloor(dROsvgGroup.height * 0.25000 + 0.5) + 0.7))
        SalesConfigControls.onyxDefault.setFill()
        rectangle5Path.fill()
        
        
        //// Rectangle 6 Drawing
        let rectangle6Path = UIBezierPath(rect: CGRect(x: dROsvgGroup.minX + fastFloor(dROsvgGroup.width * 0.20938 - 0.2) + 0.7, y: dROsvgGroup.minY + fastFloor(dROsvgGroup.height * 0.45625 - 0.1) + 0.6, width: fastFloor(dROsvgGroup.width * 0.29375 + 0.1) - fastFloor(dROsvgGroup.width * 0.20938 - 0.2) - 0.3, height: fastFloor(dROsvgGroup.height * 0.54063 + 0.2) - fastFloor(dROsvgGroup.height * 0.45625 - 0.1) - 0.3))
        SalesConfigControls.onyxDefault.setFill()
        rectangle6Path.fill()
        
        
        //// Rectangle 7 Drawing
        let rectangle7Path = UIBezierPath(rect: CGRect(x: dROsvgGroup.minX + fastFloor(dROsvgGroup.width * 0.20938 - 0.2) + 0.7, y: dROsvgGroup.minY + fastFloor(dROsvgGroup.height * 0.66563 + 0.2) + 0.3, width: fastFloor(dROsvgGroup.width * 0.29375 + 0.1) - fastFloor(dROsvgGroup.width * 0.20938 - 0.2) - 0.3, height: fastFloor(dROsvgGroup.height * 0.75000 + 0.5) - fastFloor(dROsvgGroup.height * 0.66563 + 0.2) - 0.3))
        SalesConfigControls.onyxDefault.setFill()
        rectangle7Path.fill()
    }
    
    @objc public dynamic class func drawForwardArrowIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let forwardArrowsvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// ForwardArrow.svg Group
        //// Rectangle Drawing
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: forwardArrowsvgGroup.minX + 0.54375 * forwardArrowsvgGroup.width, y: forwardArrowsvgGroup.minY + 0.50000 * forwardArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: forwardArrowsvgGroup.minX + 0.41563 * forwardArrowsvgGroup.width, y: forwardArrowsvgGroup.minY + 0.60312 * forwardArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: forwardArrowsvgGroup.minX + 0.41563 * forwardArrowsvgGroup.width, y: forwardArrowsvgGroup.minY + 0.66562 * forwardArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: forwardArrowsvgGroup.minX + 0.62500 * forwardArrowsvgGroup.width, y: forwardArrowsvgGroup.minY + 0.50000 * forwardArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: forwardArrowsvgGroup.minX + 0.41563 * forwardArrowsvgGroup.width, y: forwardArrowsvgGroup.minY + 0.33437 * forwardArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: forwardArrowsvgGroup.minX + 0.41563 * forwardArrowsvgGroup.width, y: forwardArrowsvgGroup.minY + 0.39687 * forwardArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: forwardArrowsvgGroup.minX + 0.54375 * forwardArrowsvgGroup.width, y: forwardArrowsvgGroup.minY + 0.50000 * forwardArrowsvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
    }
    
    @objc public dynamic class func drawSuccessIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let messageSuccesssvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// MessageSuccess.svg Group
        //// Rectangle Drawing
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.50000 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.20937 * messageSuccesssvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.20938 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.50000 * messageSuccesssvgGroup.height), controlPoint1: CGPoint(x: messageSuccesssvgGroup.minX + 0.33750 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.20937 * messageSuccesssvgGroup.height), controlPoint2: CGPoint(x: messageSuccesssvgGroup.minX + 0.20938 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.34062 * messageSuccesssvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.50000 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.79062 * messageSuccesssvgGroup.height), controlPoint1: CGPoint(x: messageSuccesssvgGroup.minX + 0.20938 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.66250 * messageSuccesssvgGroup.height), controlPoint2: CGPoint(x: messageSuccesssvgGroup.minX + 0.34062 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.79062 * messageSuccesssvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.79062 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.50000 * messageSuccesssvgGroup.height), controlPoint1: CGPoint(x: messageSuccesssvgGroup.minX + 0.65938 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.79062 * messageSuccesssvgGroup.height), controlPoint2: CGPoint(x: messageSuccesssvgGroup.minX + 0.79062 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.65937 * messageSuccesssvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.50000 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.20937 * messageSuccesssvgGroup.height), controlPoint1: CGPoint(x: messageSuccesssvgGroup.minX + 0.79062 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.33750 * messageSuccesssvgGroup.height), controlPoint2: CGPoint(x: messageSuccesssvgGroup.minX + 0.66250 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.20937 * messageSuccesssvgGroup.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.45312 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.64687 * messageSuccesssvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.31563 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.50937 * messageSuccesssvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.37500 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.45000 * messageSuccesssvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.45000 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.52500 * messageSuccesssvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.62500 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.35000 * messageSuccesssvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.68437 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.40937 * messageSuccesssvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: messageSuccesssvgGroup.minX + 0.45312 * messageSuccesssvgGroup.width, y: messageSuccesssvgGroup.minY + 0.64687 * messageSuccesssvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
    }
    
    @objc public dynamic class func drawErrorIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: frame.minX + 0.62342 * frame.width, y: frame.minY + 0.20937 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.38189 * frame.width, y: frame.minY + 0.20937 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.20938 * frame.width, y: frame.minY + 0.37924 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.20938 * frame.width, y: frame.minY + 0.62076 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.37924 * frame.width, y: frame.minY + 0.79063 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.62076 * frame.width, y: frame.minY + 0.79063 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.79062 * frame.width, y: frame.minY + 0.62076 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.79062 * frame.width, y: frame.minY + 0.37924 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.62342 * frame.width, y: frame.minY + 0.20937 * frame.height))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: frame.minX + 0.50133 * frame.width, y: frame.minY + 0.70835 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.45355 * frame.width, y: frame.minY + 0.66057 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.47479 * frame.width, y: frame.minY + 0.70835 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.45355 * frame.width, y: frame.minY + 0.68711 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.50133 * frame.width, y: frame.minY + 0.61280 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.45355 * frame.width, y: frame.minY + 0.63403 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.47479 * frame.width, y: frame.minY + 0.61280 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.54645 * frame.width, y: frame.minY + 0.66057 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.52787 * frame.width, y: frame.minY + 0.61280 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.54645 * frame.width, y: frame.minY + 0.63403 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.50133 * frame.width, y: frame.minY + 0.70835 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.54645 * frame.width, y: frame.minY + 0.68711 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.52787 * frame.width, y: frame.minY + 0.70835 * frame.height))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: frame.minX + 0.52787 * frame.width, y: frame.minY + 0.58095 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.47479 * frame.width, y: frame.minY + 0.58095 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.45355 * frame.width, y: frame.minY + 0.31554 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.54910 * frame.width, y: frame.minY + 0.31554 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.52787 * frame.width, y: frame.minY + 0.58095 * frame.height))
        bezier2Path.close()
        SalesConfigControls.onyxDefault.setFill()
        bezier2Path.fill()
    }
    
    @objc public dynamic class func drawTimerIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let licenceExpiringsvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// LicenceExpiring.svg Group
        //// Rectangle Drawing
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.50000 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.20937 * licenceExpiringsvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.20937 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.50000 * licenceExpiringsvgGroup.height), controlPoint1: CGPoint(x: licenceExpiringsvgGroup.minX + 0.33750 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.20937 * licenceExpiringsvgGroup.height), controlPoint2: CGPoint(x: licenceExpiringsvgGroup.minX + 0.20937 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.33750 * licenceExpiringsvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.50000 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.79062 * licenceExpiringsvgGroup.height), controlPoint1: CGPoint(x: licenceExpiringsvgGroup.minX + 0.20937 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.66250 * licenceExpiringsvgGroup.height), controlPoint2: CGPoint(x: licenceExpiringsvgGroup.minX + 0.33750 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.79062 * licenceExpiringsvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.79063 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.50000 * licenceExpiringsvgGroup.height), controlPoint1: CGPoint(x: licenceExpiringsvgGroup.minX + 0.66250 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.79062 * licenceExpiringsvgGroup.height), controlPoint2: CGPoint(x: licenceExpiringsvgGroup.minX + 0.79063 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.66250 * licenceExpiringsvgGroup.height))
        bezierPath.addCurve(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.50000 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.20937 * licenceExpiringsvgGroup.height), controlPoint1: CGPoint(x: licenceExpiringsvgGroup.minX + 0.79063 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.33750 * licenceExpiringsvgGroup.height), controlPoint2: CGPoint(x: licenceExpiringsvgGroup.minX + 0.66250 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.20937 * licenceExpiringsvgGroup.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.54063 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.50937 * licenceExpiringsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.42500 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.62500 * licenceExpiringsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.36562 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.56562 * licenceExpiringsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.45625 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.47500 * licenceExpiringsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.45625 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.33437 * licenceExpiringsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.54063 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.33437 * licenceExpiringsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: licenceExpiringsvgGroup.minX + 0.54063 * licenceExpiringsvgGroup.width, y: licenceExpiringsvgGroup.minY + 0.50937 * licenceExpiringsvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
    }
    
    @objc public dynamic class func drawEditIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let editsvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// Edit.svg Group
        //// Rectangle Drawing
        
        
        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: editsvgGroup.minX + 0.35313 * editsvgGroup.width, y: editsvgGroup.minY + 0.73750 * editsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: editsvgGroup.minX + 0.21875 * editsvgGroup.width, y: editsvgGroup.minY + 0.78125 * editsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: editsvgGroup.minX + 0.26250 * editsvgGroup.width, y: editsvgGroup.minY + 0.65000 * editsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: editsvgGroup.minX + 0.58750 * editsvgGroup.width, y: editsvgGroup.minY + 0.32500 * editsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: editsvgGroup.minX + 0.67500 * editsvgGroup.width, y: editsvgGroup.minY + 0.41250 * editsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: editsvgGroup.minX + 0.35313 * editsvgGroup.width, y: editsvgGroup.minY + 0.73750 * editsvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
        
        
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath()
        rectangle2Path.move(to: CGPoint(x: editsvgGroup.minX + 0.63434 * editsvgGroup.width, y: editsvgGroup.minY + 0.27838 * editsvgGroup.height))
        rectangle2Path.addLine(to: CGPoint(x: editsvgGroup.minX + 0.72162 * editsvgGroup.width, y: editsvgGroup.minY + 0.36566 * editsvgGroup.height))
        rectangle2Path.addLine(to: CGPoint(x: editsvgGroup.minX + 0.78129 * editsvgGroup.width, y: editsvgGroup.minY + 0.30600 * editsvgGroup.height))
        rectangle2Path.addLine(to: CGPoint(x: editsvgGroup.minX + 0.69400 * editsvgGroup.width, y: editsvgGroup.minY + 0.21871 * editsvgGroup.height))
        rectangle2Path.addLine(to: CGPoint(x: editsvgGroup.minX + 0.63434 * editsvgGroup.width, y: editsvgGroup.minY + 0.27838 * editsvgGroup.height))
        rectangle2Path.close()
        SalesConfigControls.onyxDefault.setFill()
        rectangle2Path.fill()
    }
    
    @objc public dynamic class func drawBackArrowIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let backArrowsvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// BackArrow.svg Group
        //// Rectangle Drawing
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: backArrowsvgGroup.minX + 0.45625 * backArrowsvgGroup.width, y: backArrowsvgGroup.minY + 0.50000 * backArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: backArrowsvgGroup.minX + 0.58437 * backArrowsvgGroup.width, y: backArrowsvgGroup.minY + 0.39687 * backArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: backArrowsvgGroup.minX + 0.58437 * backArrowsvgGroup.width, y: backArrowsvgGroup.minY + 0.33437 * backArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: backArrowsvgGroup.minX + 0.37500 * backArrowsvgGroup.width, y: backArrowsvgGroup.minY + 0.50000 * backArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: backArrowsvgGroup.minX + 0.58437 * backArrowsvgGroup.width, y: backArrowsvgGroup.minY + 0.66562 * backArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: backArrowsvgGroup.minX + 0.58437 * backArrowsvgGroup.width, y: backArrowsvgGroup.minY + 0.60312 * backArrowsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: backArrowsvgGroup.minX + 0.45625 * backArrowsvgGroup.width, y: backArrowsvgGroup.minY + 0.50000 * backArrowsvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
    }
    
    @objc public dynamic class func drawBasketIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        
        //// Subframes
        let basketsvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// Basket.svg Group
        //// Rectangle Drawing
        
        
        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: basketsvgGroup.minX + 0.85313 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.77188 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.79063 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.22812 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.79063 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.14688 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.23125 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.30000 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.70938 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.70000 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.70938 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.76875 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.85313 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: basketsvgGroup.minX + 0.79063 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.78438 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33438 * basketsvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.91563 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33438 * basketsvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.91563 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezier2Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.79063 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezier2Path.close()
        SalesConfigControls.onyxDefault.setFill()
        bezier2Path.fill()
        
        
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: basketsvgGroup.minX + 0.20938 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezier3Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.08438 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezier3Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.08438 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33438 * basketsvgGroup.height))
        bezier3Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.21563 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33438 * basketsvgGroup.height))
        bezier3Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.20938 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.29063 * basketsvgGroup.height))
        bezier3Path.close()
        SalesConfigControls.onyxDefault.setFill()
        bezier3Path.fill()
        
        
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRect(x: basketsvgGroup.minX + fastFloor(basketsvgGroup.width * 0.22812 + 0.2) + 0.3, y: basketsvgGroup.minY + fastFloor(basketsvgGroup.height * 0.58437 - 0.2) + 0.7, width: fastFloor(basketsvgGroup.width * 0.76875 - 0.1) - fastFloor(basketsvgGroup.width * 0.22812 + 0.2) + 0.3, height: fastFloor(basketsvgGroup.height * 0.62500 + 0.5) - fastFloor(basketsvgGroup.height * 0.58437 - 0.2) - 0.7))
        SalesConfigControls.onyxDefault.setFill()
        rectangle2Path.fill()
        
        
        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(rect: CGRect(x: basketsvgGroup.minX + fastFloor(basketsvgGroup.width * 0.22812 + 0.2) + 0.3, y: basketsvgGroup.minY + fastFloor(basketsvgGroup.height * 0.45937 - 0.2) + 0.7, width: fastFloor(basketsvgGroup.width * 0.76875 - 0.1) - fastFloor(basketsvgGroup.width * 0.22812 + 0.2) + 0.3, height: fastFloor(basketsvgGroup.height * 0.50000 + 0.5) - fastFloor(basketsvgGroup.height * 0.45937 - 0.2) - 0.7))
        SalesConfigControls.onyxDefault.setFill()
        rectangle3Path.fill()
        
        
        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: basketsvgGroup.minX + fastFloor(basketsvgGroup.width * 0.20938 - 0.2) + 0.7, y: basketsvgGroup.minY + fastFloor(basketsvgGroup.height * 0.33437 - 0.2) + 0.7, width: fastFloor(basketsvgGroup.width * 0.79375 + 0.1) - fastFloor(basketsvgGroup.width * 0.20938 - 0.2) - 0.3, height: fastFloor(basketsvgGroup.height * 0.37500 + 0.5) - fastFloor(basketsvgGroup.height * 0.33437 - 0.2) - 0.7))
        SalesConfigControls.onyxDefault.setFill()
        rectangle4Path.fill()
        
        
        //// Rectangle 5 Drawing
        let rectangle5Path = UIBezierPath()
        rectangle5Path.move(to: CGPoint(x: basketsvgGroup.minX + 0.39602 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.71039 * basketsvgGroup.height))
        rectangle5Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.43652 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.70720 * basketsvgGroup.height))
        rectangle5Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.40710 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33336 * basketsvgGroup.height))
        rectangle5Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.36660 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33655 * basketsvgGroup.height))
        rectangle5Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.39602 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.71039 * basketsvgGroup.height))
        rectangle5Path.close()
        SalesConfigControls.onyxDefault.setFill()
        rectangle5Path.fill()
        
        
        //// Rectangle 6 Drawing
        let rectangle6Path = UIBezierPath()
        rectangle6Path.move(to: CGPoint(x: basketsvgGroup.minX + 0.56191 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.70720 * basketsvgGroup.height))
        rectangle6Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.60241 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.71039 * basketsvgGroup.height))
        rectangle6Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.63184 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33655 * basketsvgGroup.height))
        rectangle6Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.59134 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.33336 * basketsvgGroup.height))
        rectangle6Path.addLine(to: CGPoint(x: basketsvgGroup.minX + 0.56191 * basketsvgGroup.width, y: basketsvgGroup.minY + 0.70720 * basketsvgGroup.height))
        rectangle6Path.close()
        SalesConfigControls.onyxDefault.setFill()
        rectangle6Path.fill()
    }
    
    @objc public dynamic class func drawPlusIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32)) {
        
        
        //// Subframes
        let plussvgGroup: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        
        
        //// Plus.svg Group
        //// Rectangle Drawing
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: plussvgGroup.minX + 0.70937 * plussvgGroup.width, y: plussvgGroup.minY + 0.54063 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.54375 * plussvgGroup.width, y: plussvgGroup.minY + 0.54063 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.54375 * plussvgGroup.width, y: plussvgGroup.minY + 0.70625 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.45937 * plussvgGroup.width, y: plussvgGroup.minY + 0.70625 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.45937 * plussvgGroup.width, y: plussvgGroup.minY + 0.54063 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.29063 * plussvgGroup.width, y: plussvgGroup.minY + 0.54063 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.29063 * plussvgGroup.width, y: plussvgGroup.minY + 0.45625 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.45625 * plussvgGroup.width, y: plussvgGroup.minY + 0.45625 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.45625 * plussvgGroup.width, y: plussvgGroup.minY + 0.29063 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.54063 * plussvgGroup.width, y: plussvgGroup.minY + 0.29063 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.54063 * plussvgGroup.width, y: plussvgGroup.minY + 0.45625 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.70625 * plussvgGroup.width, y: plussvgGroup.minY + 0.45625 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.70625 * plussvgGroup.width, y: plussvgGroup.minY + 0.54063 * plussvgGroup.height))
        bezierPath.addLine(to: CGPoint(x: plussvgGroup.minX + 0.70937 * plussvgGroup.width, y: plussvgGroup.minY + 0.54063 * plussvgGroup.height))
        bezierPath.close()
        SalesConfigControls.onyxDefault.setFill()
        bezierPath.fill()
    }
    
    @objc public dynamic class func drawOnyxButton(frame: CGRect = CGRect(x: 0, y: 0, width: 90, height: 61), title: String = "Button", pressed: Bool = true, selected: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        //// Color Declarations
        let onyxButtonBackgroundStop1 = UIColor(red: 0.447, green: 0.447, blue: 0.447, alpha: 1.000)
        let onyxButtonBackgroundStop2 = UIColor(red: 0.373, green: 0.373, blue: 0.373, alpha: 1.000)
        let onyxButtonBackgroundStop3 = UIColor(red: 0.345, green: 0.345, blue: 0.345, alpha: 1.000)
        let onyxButtonLeftRightShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.100)
        let onyxButtonLeftRightShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.200)
        let onyxButtonTopShineColor5 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopTopShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let color = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0)
        
        //// Gradient Declarations
        let onyxButtonBackground = CGGradient(colorsSpace: nil, colors: [onyxButtonBackgroundStop1.cgColor, onyxButtonBackgroundStop2.cgColor, onyxButtonBackgroundStop3.cgColor] as CFArray, locations: [0, 0.6, 1])!
        let onyxButtonRightShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor3.cgColor, onyxButtonLeftRightShineColor2.cgColor] as CFArray, locations: [0.98, 1])!
        let onyxButtonTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopShineColor5.cgColor, onyxButtonTopShineColor5.blended(withFraction: 0.5, of: onyxButtonTopShineColor3).cgColor, onyxButtonTopShineColor3.cgColor, onyxButtonTopShineColor.cgColor] as CFArray, locations: [0.85, 0.93, 0.98, 1])!
        let onyxButtonTopTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopTopShineColor2.cgColor, onyxButtonTopTopShineColor.cgColor] as CFArray, locations: [0.97, 1])!
        let onyxButtonLeftShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor2.cgColor, onyxButtonLeftRightShineColor3.cgColor] as CFArray, locations: [0, 0.02])!
        
        //// Shadow Declarations
        let buttonDropShadow = NSShadow()
        buttonDropShadow.shadowColor = UIColor.black.withAlphaComponent(0.3)
        buttonDropShadow.shadowOffset = CGSize(width: 0, height: 2)
        buttonDropShadow.shadowBlurRadius = 2
        
        //// Layer E Drawing
        context.saveGState()
        context.setAlpha(0.6)
        
        let layerEPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 1), cornerRadius: 5)
        UIColor.black.setFill()
        layerEPath.fill()
        
        context.restoreGState()
        
        
        //// Layer D Drawing
        let layerDRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1)
        let layerDPath = UIBezierPath(roundedRect: layerDRect, cornerRadius: 5)
        context.saveGState()
        context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        layerDPath.addClip()
        context.drawLinearGradient(onyxButtonBackground,
                                   start: CGPoint(x: layerDRect.midX, y: layerDRect.minY),
                                   end: CGPoint(x: layerDRect.midX, y: layerDRect.maxY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()
        
        
        
        if (selected) {
            //// Layer Selected Drawing
            let layerSelectedPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1), cornerRadius: 5)
            context.saveGState()
            context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
            SalesConfigControls.onyxSelectedColour.setFill()
            layerSelectedPath.fill()
            context.restoreGState()
            
        }
        
        
        //// Layer C RIght Drawing
        let layerCRIghtRect = CGRect(x: frame.minX + frame.width - 90, y: frame.minY, width: 90, height: frame.height - 1)
        let layerCRIghtPath = UIBezierPath(roundedRect: layerCRIghtRect, cornerRadius: 5)
        context.saveGState()
        layerCRIghtPath.addClip()
        context.drawLinearGradient(onyxButtonRightShine,
                                   start: CGPoint(x: layerCRIghtRect.minX, y: layerCRIghtRect.midY),
                                   end: CGPoint(x: layerCRIghtRect.maxX, y: layerCRIghtRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer C Left Drawing
        let layerCLeftRect = CGRect(x: frame.minX, y: frame.minY, width: 90, height: frame.height - 1)
        let layerCLeftPath = UIBezierPath(roundedRect: layerCLeftRect, cornerRadius: 5)
        context.saveGState()
        layerCLeftPath.addClip()
        context.drawLinearGradient(onyxButtonLeftShine,
                                   start: CGPoint(x: layerCLeftRect.minX, y: layerCLeftRect.midY),
                                   end: CGPoint(x: layerCLeftRect.maxX, y: layerCLeftRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer B Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerBRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 56)
        let layerBPath = UIBezierPath(roundedRect: layerBRect, cornerRadius: 5)
        context.saveGState()
        layerBPath.addClip()
        context.drawLinearGradient(onyxButtonTopShine,
                                   start: CGPoint(x: layerBRect.midX, y: layerBRect.maxY),
                                   end: CGPoint(x: layerBRect.midX, y: layerBRect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        //// Layer A Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerARect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerAPath = UIBezierPath(roundedRect: layerARect, cornerRadius: 5)
        context.saveGState()
        layerAPath.addClip()
        context.drawLinearGradient(onyxButtonTopTopShine,
                                   start: CGPoint(x: layerARect.midX, y: layerARect.maxY),
                                   end: CGPoint(x: layerARect.midX, y: layerARect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        if (pressed) {
            //// Layer Pressed Overlay Drawing
            let layerPressedOverlayPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1), cornerRadius: 5)
            context.saveGState()
            context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
            color.setFill()
            layerPressedOverlayPath.fill()
            context.restoreGState()
            
        }
        
        
        //// Text Drawing
        let textRect = CGRect(x: frame.minX, y: frame.minY + fastFloor((frame.height - 60) * 0.00000 + 0.5), width: frame.width, height: 60)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: UIFont.smallSystemFontSize), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: textStyle]
        
        let textTextHeight: CGFloat = title.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        title.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
    }
    
    @objc public dynamic class func drawOnyxMobileHeader(frame: CGRect = CGRect(x: 0, y: 0, width: 120, height: 66), title: String = "Button") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        
        //// Shadow Declarations
        let onyxHeaderShadow = NSShadow()
        onyxHeaderShadow.shadowColor = UIColor.black
        onyxHeaderShadow.shadowOffset = CGSize(width: 0, height: 2)
        onyxHeaderShadow.shadowBlurRadius = 5
        
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: fastFloor((frame.height) * 0.90909 + 0.5)))
        context.saveGState()
        context.setShadow(offset: onyxHeaderShadow.shadowOffset, blur: onyxHeaderShadow.shadowBlurRadius, color: (onyxHeaderShadow.shadowColor as! UIColor).cgColor)
        SalesConfigControls.onyxOrange.setFill()
        rectanglePath.fill()
        context.restoreGState()
        
        
        
        //// Text Drawing
        let textRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 6)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: UIFont.systemFontSize), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: textStyle]
        
        let textTextHeight: CGFloat = title.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        title.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
    }
    
    @objc public dynamic class func drawOnyxTextBox(frame: CGRect = CGRect(x: 0, y: 0, width: 120, height: 70)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Color Declarations
        let color3 = UIColor(red: 0.369, green: 0.369, blue: 0.369, alpha: 1.000)
        let gradientColor = UIColor(red: 0.157, green: 0.157, blue: 0.157, alpha: 1.000)
        let gradientColor2 = UIColor(red: 0.216, green: 0.216, blue: 0.220, alpha: 1.000)
        let gradientColor3 = UIColor(red: 0.275, green: 0.275, blue: 0.282, alpha: 1.000)
        
        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [gradientColor.cgColor, gradientColor2.cgColor, gradientColor2.blended(withFraction: 0.5, of: gradientColor3).cgColor, gradientColor3.cgColor] as CFArray, locations: [0, 0.03, 0.08, 0.35])!
        
        //// Layer D Drawing
        let layerDPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 3), cornerRadius: 3)
        UIColor.black.setFill()
        layerDPath.fill()
        
        
        //// Layer C Drawing
        let layerCPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 2, width: frame.width, height: frame.height - 2), cornerRadius: 3)
        color3.setFill()
        layerCPath.fill()
        
        
        //// Layer B Drawing
        let layerBRect = CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 2)
        let layerBPath = UIBezierPath(roundedRect: layerBRect, cornerRadius: 3)
        context.saveGState()
        layerBPath.addClip()
        context.drawLinearGradient(gradient,
                                   start: CGPoint(x: layerBRect.midX, y: layerBRect.minY),
                                   end: CGPoint(x: layerBRect.midX, y: layerBRect.maxY),
                                   options: [])
        context.restoreGState()
    }
    
    @objc public dynamic class func drawOnyxOrangeButton(frame: CGRect = CGRect(x: 0, y: 0, width: 90, height: 61), title: String = "Button", pressed: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        //// Color Declarations
        let onyxButtonLeftRightShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.100)
        let onyxButtonLeftRightShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.200)
        let onyxButtonTopShineColor5 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopTopShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let color = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.150)
        
        //// Gradient Declarations
        let onyxButtonRightShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor3.cgColor, onyxButtonLeftRightShineColor2.cgColor] as CFArray, locations: [0.98, 1])!
        let onyxButtonTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopShineColor5.cgColor, onyxButtonTopShineColor5.blended(withFraction: 0.5, of: onyxButtonTopShineColor3).cgColor, onyxButtonTopShineColor3.cgColor, onyxButtonTopShineColor.cgColor] as CFArray, locations: [0.85, 0.93, 0.98, 1])!
        let onyxButtonTopTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopTopShineColor2.cgColor, onyxButtonTopTopShineColor.cgColor] as CFArray, locations: [0.97, 1])!
        let onyxButtonLeftShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor2.cgColor, onyxButtonLeftRightShineColor3.cgColor] as CFArray, locations: [0, 0.02])!
        
        //// Shadow Declarations
        let buttonDropShadow = NSShadow()
        buttonDropShadow.shadowColor = UIColor.black.withAlphaComponent(0.3)
        buttonDropShadow.shadowOffset = CGSize(width: 0, height: 2)
        buttonDropShadow.shadowBlurRadius = 2
        
        //// Layer E Drawing
        context.saveGState()
        context.setAlpha(0.6)
        
        let layerEPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 1), cornerRadius: 5)
        UIColor.black.setFill()
        layerEPath.fill()
        
        context.restoreGState()
        
        
        //// Orange Layer Drawing
        let orangeLayerPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1), cornerRadius: 5)
        context.saveGState()
        context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
        SalesConfigControls.onyxSelectedColour.setFill()
        orangeLayerPath.fill()
        context.restoreGState()
        
        
        
        //// Layer C RIght Drawing
        let layerCRIghtRect = CGRect(x: frame.minX + frame.width - 90, y: frame.minY, width: 90, height: frame.height - 1)
        let layerCRIghtPath = UIBezierPath(roundedRect: layerCRIghtRect, cornerRadius: 5)
        context.saveGState()
        layerCRIghtPath.addClip()
        context.drawLinearGradient(onyxButtonRightShine,
                                   start: CGPoint(x: layerCRIghtRect.minX, y: layerCRIghtRect.midY),
                                   end: CGPoint(x: layerCRIghtRect.maxX, y: layerCRIghtRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer C Left Drawing
        let layerCLeftRect = CGRect(x: frame.minX, y: frame.minY, width: 90, height: frame.height - 1)
        let layerCLeftPath = UIBezierPath(roundedRect: layerCLeftRect, cornerRadius: 5)
        context.saveGState()
        layerCLeftPath.addClip()
        context.drawLinearGradient(onyxButtonLeftShine,
                                   start: CGPoint(x: layerCLeftRect.minX, y: layerCLeftRect.midY),
                                   end: CGPoint(x: layerCLeftRect.maxX, y: layerCLeftRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer B Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerBRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 56)
        let layerBPath = UIBezierPath(roundedRect: layerBRect, cornerRadius: 5)
        context.saveGState()
        layerBPath.addClip()
        context.drawLinearGradient(onyxButtonTopShine,
                                   start: CGPoint(x: layerBRect.midX, y: layerBRect.maxY),
                                   end: CGPoint(x: layerBRect.midX, y: layerBRect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        //// Layer A Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerARect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerAPath = UIBezierPath(roundedRect: layerARect, cornerRadius: 5)
        context.saveGState()
        layerAPath.addClip()
        context.drawLinearGradient(onyxButtonTopTopShine,
                                   start: CGPoint(x: layerARect.midX, y: layerARect.maxY),
                                   end: CGPoint(x: layerARect.midX, y: layerARect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        if (pressed) {
            //// Layer Pressed Overlay Drawing
            let layerPressedOverlayPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1), cornerRadius: 5)
            context.saveGState()
            context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
            color.setFill()
            layerPressedOverlayPath.fill()
            context.restoreGState()
            
        }
        
        
        //// Text Drawing
        let textRect = CGRect(x: frame.minX, y: frame.minY + fastFloor((frame.height - 60) * 0.00000 + 0.5), width: frame.width, height: 60)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: UIFont.smallSystemFontSize), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: textStyle]
        
        let textTextHeight: CGFloat = title.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        title.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
    }
    
    @objc public dynamic class func drawBusySpinner(frame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Color Declarations
        let fillColor2 = UIColor(red: 0.278, green: 0.278, blue: 0.286, alpha: 1.000)
        let gradientColor4 = UIColor(red: 0.969, green: 0.561, blue: 0.133, alpha: 0.000)
        let gradientColor5 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let gradientColor6 = UIColor(red: 0.984, green: 0.690, blue: 0.231, alpha: 1.000)
        let gradientColor7 = UIColor(red: 0.980, green: 0.667, blue: 0.216, alpha: 1.000)
        let gradientColor8 = UIColor(red: 0.973, green: 0.596, blue: 0.176, alpha: 1.000)
        let gradientColor9 = UIColor(red: 0.961, green: 0.502, blue: 0.125, alpha: 1.000)
        
        //// Gradient Declarations
        let lineargradient = CGGradient(colorsSpace: nil, colors: [gradientColor4.cgColor, gradientColor5.cgColor, gradientColor5.cgColor, gradientColor5.cgColor] as CFArray, locations: [0.14, 0.76, 0.97, 1])!
        let lineargradient2 = CGGradient(colorsSpace: nil, colors: [gradientColor4.cgColor, gradientColor6.cgColor, gradientColor7.cgColor, gradientColor8.cgColor, gradientColor9.cgColor] as CFArray, locations: [0.14, 0.52, 0.65, 0.83, 1])!
        
        
        //// Subframes
        let group: CGRect = CGRect(x: frame.minX + 1, y: frame.minY + 1, width: frame.width - 2, height: frame.height - 2)
        
        
        //// Group
        //// Background Drawing
        let backgroundPath = UIBezierPath()
        backgroundPath.move(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.00000 * group.height))
        backgroundPath.addLine(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.00000 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.50000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.22386 * group.width, y: group.minY + 0.00000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.22386 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 1.00000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.77614 * group.height), controlPoint2: CGPoint(x: group.minX + 0.22386 * group.width, y: group.minY + 1.00000 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.50000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.77614 * group.width, y: group.minY + 1.00000 * group.height), controlPoint2: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.77614 * group.height))
        backgroundPath.addLine(to: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.50000 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.00000 * group.height), controlPoint1: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.22386 * group.height), controlPoint2: CGPoint(x: group.minX + 0.77614 * group.width, y: group.minY + 0.00000 * group.height))
        backgroundPath.close()
        backgroundPath.move(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.84615 * group.height))
        backgroundPath.addLine(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.84615 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 0.15385 * group.width, y: group.minY + 0.50000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.30882 * group.width, y: group.minY + 0.84615 * group.height), controlPoint2: CGPoint(x: group.minX + 0.15385 * group.width, y: group.minY + 0.69118 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.15385 * group.height), controlPoint1: CGPoint(x: group.minX + 0.15385 * group.width, y: group.minY + 0.30882 * group.height), controlPoint2: CGPoint(x: group.minX + 0.30882 * group.width, y: group.minY + 0.15385 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 0.84615 * group.width, y: group.minY + 0.50000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.69118 * group.width, y: group.minY + 0.15385 * group.height), controlPoint2: CGPoint(x: group.minX + 0.84615 * group.width, y: group.minY + 0.30882 * group.height))
        backgroundPath.addLine(to: CGPoint(x: group.minX + 0.84615 * group.width, y: group.minY + 0.50000 * group.height))
        backgroundPath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.84615 * group.height), controlPoint1: CGPoint(x: group.minX + 0.84615 * group.width, y: group.minY + 0.69118 * group.height), controlPoint2: CGPoint(x: group.minX + 0.69118 * group.width, y: group.minY + 0.84615 * group.height))
        backgroundPath.close()
        fillColor2.setFill()
        backgroundPath.fill()
        
        
        //// Flare Drawing
        let flarePath = UIBezierPath()
        flarePath.move(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.03061 * group.height))
        flarePath.addLine(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.03061 * group.height))
        flarePath.addCurve(to: CGPoint(x: group.minX + 0.03061 * group.width, y: group.minY + 0.50157 * group.height), controlPoint1: CGPoint(x: group.minX + 0.24076 * group.width, y: group.minY + 0.03061 * group.height), controlPoint2: CGPoint(x: group.minX + 0.03061 * group.width, y: group.minY + 0.24147 * group.height))
        flarePath.addLine(to: CGPoint(x: group.minX + 0.10884 * group.width, y: group.minY + 0.50157 * group.height))
        flarePath.addLine(to: CGPoint(x: group.minX + 0.10884 * group.width, y: group.minY + 0.50157 * group.height))
        flarePath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.10911 * group.height), controlPoint1: CGPoint(x: group.minX + 0.10884 * group.width, y: group.minY + 0.28482 * group.height), controlPoint2: CGPoint(x: group.minX + 0.28397 * group.width, y: group.minY + 0.10911 * group.height))
        flarePath.addCurve(to: CGPoint(x: group.minX + 0.89116 * group.width, y: group.minY + 0.50157 * group.height), controlPoint1: CGPoint(x: group.minX + 0.71603 * group.width, y: group.minY + 0.10911 * group.height), controlPoint2: CGPoint(x: group.minX + 0.89116 * group.width, y: group.minY + 0.28482 * group.height))
        flarePath.addLine(to: CGPoint(x: group.minX + 0.89116 * group.width, y: group.minY + 0.50157 * group.height))
        flarePath.addLine(to: CGPoint(x: group.minX + 0.89116 * group.width, y: group.minY + 0.50157 * group.height))
        flarePath.addCurve(to: CGPoint(x: group.minX + 0.93027 * group.width, y: group.minY + 0.54082 * group.height), controlPoint1: CGPoint(x: group.minX + 0.89116 * group.width, y: group.minY + 0.52325 * group.height), controlPoint2: CGPoint(x: group.minX + 0.90867 * group.width, y: group.minY + 0.54082 * group.height))
        flarePath.addCurve(to: CGPoint(x: group.minX + 0.96939 * group.width, y: group.minY + 0.50157 * group.height), controlPoint1: CGPoint(x: group.minX + 0.95188 * group.width, y: group.minY + 0.54082 * group.height), controlPoint2: CGPoint(x: group.minX + 0.96939 * group.width, y: group.minY + 0.52325 * group.height))
        flarePath.addLine(to: CGPoint(x: group.minX + 0.96939 * group.width, y: group.minY + 0.50157 * group.height))
        flarePath.addCurve(to: CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.03061 * group.height), controlPoint1: CGPoint(x: group.minX + 0.96939 * group.width, y: group.minY + 0.24147 * group.height), controlPoint2: CGPoint(x: group.minX + 0.75924 * group.width, y: group.minY + 0.03061 * group.height))
        flarePath.close()
        context.saveGState()
        flarePath.addClip()
        let flareBounds: CGRect = flarePath.cgPath.boundingBoxOfPath
        context.drawLinearGradient(lineargradient2,
                                   start: CGPoint(x: flareBounds.midX + -46 * flareBounds.width / 92, y: flareBounds.midY + 0 * flareBounds.height / 50),
                                   end: CGPoint(x: flareBounds.midX + 46 * flareBounds.width / 92, y: flareBounds.midY + 0 * flareBounds.height / 50),
                                   options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        
        
        //// Bezier Drawing
        context.saveGState()
        context.setAlpha(0.6)
        
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.11865 * group.width, y: group.minY + 0.50163 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.08002 * group.width, y: group.minY + 0.50163 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.08002 * group.width, y: group.minY + 0.50163 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.50494 * group.width, y: group.minY + 0.07063 * group.height), controlPoint1: CGPoint(x: group.minX + 0.08002 * group.width, y: group.minY + 0.26360 * group.height), controlPoint2: CGPoint(x: group.minX + 0.27026 * group.width, y: group.minY + 0.07063 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.92986 * group.width, y: group.minY + 0.50163 * group.height), controlPoint1: CGPoint(x: group.minX + 0.73962 * group.width, y: group.minY + 0.07063 * group.height), controlPoint2: CGPoint(x: group.minX + 0.92986 * group.width, y: group.minY + 0.26360 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.92793 * group.width, y: group.minY + 0.54082 * group.height), controlPoint1: CGPoint(x: group.minX + 0.92986 * group.width, y: group.minY + 0.51496 * group.height), controlPoint2: CGPoint(x: group.minX + 0.92986 * group.width, y: group.minY + 0.52789 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.92793 * group.width, y: group.minY + 0.54082 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.88930 * group.width, y: group.minY + 0.50163 * group.height), controlPoint1: CGPoint(x: group.minX + 0.90659 * group.width, y: group.minY + 0.54082 * group.height), controlPoint2: CGPoint(x: group.minX + 0.88930 * group.width, y: group.minY + 0.52327 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.88930 * group.width, y: group.minY + 0.50163 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.88930 * group.width, y: group.minY + 0.50163 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.50301 * group.width, y: group.minY + 0.10981 * group.height), controlPoint1: CGPoint(x: group.minX + 0.88930 * group.width, y: group.minY + 0.28524 * group.height), controlPoint2: CGPoint(x: group.minX + 0.71635 * group.width, y: group.minY + 0.10981 * group.height))
        bezierPath.addCurve(to: CGPoint(x: group.minX + 0.11672 * group.width, y: group.minY + 0.50163 * group.height), controlPoint1: CGPoint(x: group.minX + 0.28967 * group.width, y: group.minY + 0.10981 * group.height), controlPoint2: CGPoint(x: group.minX + 0.11672 * group.width, y: group.minY + 0.28524 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.11865 * group.width, y: group.minY + 0.50163 * group.height))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        let bezierBounds: CGRect = bezierPath.cgPath.boundingBoxOfPath
        context.drawLinearGradient(lineargradient,
                                   start: CGPoint(x: bezierBounds.midX + -41.64 * bezierBounds.width / 83.28, y: bezierBounds.midY + 0 * bezierBounds.height / 46.08),
                                   end: CGPoint(x: bezierBounds.midX + 41.64 * bezierBounds.width / 83.28, y: bezierBounds.midY + 0 * bezierBounds.height / 46.08),
                                   options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        
        context.restoreGState()
    }
    
    @objc public dynamic class func drawWarningToast(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 480, height: 80), resizing: ResizingBehavior = .aspectFit, warningHeader: String = "This is an alert", warningDetail: String = "This is alert detail") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 480, height: 80), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 480, y: resizedFrame.height / 80)
        
        
        //// Color Declarations
        let onyxBackground = UIColor(red: 0.157, green: 0.157, blue: 0.157, alpha: 1.000)
        
        //// Group
        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(rect: CGRect(x: 81, y: 0, width: 399, height: 80))
        onyxBackground.setFill()
        rectangle3Path.fill()
        
        
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 1, y: 1, width: 478, height: 78))
        SalesConfigControls.onyxOrange.setStroke()
        rectanglePath.lineWidth = 2
        rectanglePath.stroke()
        
        
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 81, height: 80))
        SalesConfigControls.onyxOrange.setFill()
        rectangle2Path.fill()
        
        
        //// Text Drawing
        let textRect = CGRect(x: 92, y: 14, width: 385, height: 30)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 16), NSAttributedString.Key.foregroundColor: SalesConfigControls.onyxOrange, NSAttributedString.Key.paragraphStyle: textStyle]
        
        let textTextHeight: CGFloat = warningHeader.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        warningHeader.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        
        //// Text 2 Drawing
        let text2Rect = CGRect(x: 92, y: 40, width: 385, height: 25)
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .left
        let text2FontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: UIFont.smallSystemFontSize), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: text2Style]
        
        let text2TextHeight: CGFloat = warningDetail.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        warningDetail.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 52.71, y: 45.9))
        bezierPath.addLine(to: CGPoint(x: 42.17, y: 27.83))
        bezierPath.addLine(to: CGPoint(x: 42.16, y: 27.82))
        bezierPath.addCurve(to: CGPoint(x: 39.98, y: 27.17), controlPoint1: CGPoint(x: 41.74, y: 27.06), controlPoint2: CGPoint(x: 40.77, y: 26.77))
        bezierPath.addCurve(to: CGPoint(x: 39.31, y: 27.84), controlPoint1: CGPoint(x: 39.69, y: 27.32), controlPoint2: CGPoint(x: 39.46, y: 27.56))
        bezierPath.addLine(to: CGPoint(x: 28.77, y: 45.9))
        bezierPath.addLine(to: CGPoint(x: 28.77, y: 45.9))
        bezierPath.addCurve(to: CGPoint(x: 29.37, y: 48.25), controlPoint1: CGPoint(x: 28.27, y: 46.71), controlPoint2: CGPoint(x: 28.54, y: 47.76))
        bezierPath.addCurve(to: CGPoint(x: 30.22, y: 48.49), controlPoint1: CGPoint(x: 29.63, y: 48.4), controlPoint2: CGPoint(x: 29.92, y: 48.48))
        bezierPath.addLine(to: CGPoint(x: 51.29, y: 48.49))
        bezierPath.addLine(to: CGPoint(x: 51.29, y: 48.49))
        bezierPath.addCurve(to: CGPoint(x: 52.96, y: 46.69), controlPoint1: CGPoint(x: 52.27, y: 48.44), controlPoint2: CGPoint(x: 53.01, y: 47.64))
        bezierPath.addCurve(to: CGPoint(x: 52.71, y: 45.9), controlPoint1: CGPoint(x: 52.95, y: 46.41), controlPoint2: CGPoint(x: 52.86, y: 46.14))
        bezierPath.addLine(to: CGPoint(x: 52.71, y: 45.9))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 40.75, y: 47.17))
        bezierPath.addLine(to: CGPoint(x: 40.75, y: 47.17))
        bezierPath.addCurve(to: CGPoint(x: 38.8, y: 45.29), controlPoint1: CGPoint(x: 39.67, y: 47.17), controlPoint2: CGPoint(x: 38.8, y: 46.33))
        bezierPath.addCurve(to: CGPoint(x: 40.75, y: 43.41), controlPoint1: CGPoint(x: 38.8, y: 44.25), controlPoint2: CGPoint(x: 39.67, y: 43.41))
        bezierPath.addCurve(to: CGPoint(x: 42.69, y: 45.29), controlPoint1: CGPoint(x: 41.82, y: 43.41), controlPoint2: CGPoint(x: 42.69, y: 44.25))
        bezierPath.addLine(to: CGPoint(x: 42.69, y: 45.29))
        bezierPath.addCurve(to: CGPoint(x: 40.75, y: 47.17), controlPoint1: CGPoint(x: 42.69, y: 46.33), controlPoint2: CGPoint(x: 41.82, y: 47.17))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 41.86, y: 42.24))
        bezierPath.addLine(to: CGPoint(x: 39.64, y: 42.24))
        bezierPath.addLine(to: CGPoint(x: 38.75, y: 31.37))
        bezierPath.addLine(to: CGPoint(x: 42.8, y: 31.37))
        bezierPath.addLine(to: CGPoint(x: 41.86, y: 42.24))
        bezierPath.close()
        UIColor.white.setFill()
        bezierPath.fill()
        
        context.restoreGState()
        
    }
    
    @objc public dynamic class func drawOnyxMobileFooter(frame: CGRect = CGRect(x: 0, y: 0, width: 50, height: 50), cornerRadius : CGFloat) {
        //// Color Declarations
        let onyxButtonBackgroundStop1 = UIColor(red: 0.447, green: 0.447, blue: 0.447, alpha: 1.000)
        let onyx505050 = UIColor(red: 0.314, green: 0.314, blue: 0.314, alpha: 1.000)
        
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 10), cornerRadius: cornerRadius)
        onyxButtonBackgroundStop1.setFill()
        rectangle2Path.fill()
        
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY+1, width: frame.width, height: frame.height-1), cornerRadius: cornerRadius)
        onyx505050.setFill()
        rectanglePath.fill()
    }
    
    @objc public dynamic class func drawOnyxTableCell(frame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 50), selected: Bool = true, cellLabel: String = "Hello, World!") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Color Declarations
        let _5White = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.050)
        let _15White = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.150)
        let cellSelectionFillColor = UIColor(red: 1.000, green: 0.910, blue: 0.659, alpha: 1.000)
        let cellSelectionFillColor3 = UIColor(red: 1.000, green: 0.651, blue: 0.259, alpha: 1.000)
        let cellSelectionFillColor5 = UIColor(red: 1.000, green: 0.702, blue: 0.337, alpha: 1.000)
        let cellSelectionFillColor7 = UIColor(red: 1.000, green: 0.655, blue: 0.267, alpha: 1.000)
        
        //// Gradient Declarations
        let cellSelectionFill = CGGradient(colorsSpace: nil, colors: [cellSelectionFillColor.cgColor, cellSelectionFillColor5.cgColor, cellSelectionFillColor7.cgColor, cellSelectionFillColor3.cgColor] as CFArray, locations: [0, 0.08, 0.15, 0.28])!
        
        if (selected) {
            //// Selected Bg Drawing
            let selectedBgPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 2), cornerRadius: 3)
            _15White.setFill()
            selectedBgPath.fill()
        }
        
        
        //// Standard Bg Drawing
        let standardBgPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 2), cornerRadius: 3)
        _5White.setFill()
        standardBgPath.fill()
        
        
        if (selected) {
            //// Rectangle Drawing
            let rectangleRect = CGRect(x: frame.minX, y: frame.minY + 1, width: 3, height: 48)
            let rectanglePath = UIBezierPath(roundedRect: rectangleRect, byRoundingCorners: [.topLeft, .bottomLeft], cornerRadii: CGSize(width: 1.5, height: 1.5))
            rectanglePath.close()
            context.saveGState()
            rectanglePath.addClip()
            context.drawLinearGradient(cellSelectionFill,
                                       start: CGPoint(x: rectangleRect.midX, y: rectangleRect.minY),
                                       end: CGPoint(x: rectangleRect.midX, y: rectangleRect.maxY),
                                       options: [])
            context.restoreGState()
        }
        
        
        //// Text Drawing
        let textRect = CGRect(x: frame.minX + 20, y: frame.minY + 1, width: 170, height: 48)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: UIFont.labelFontSize), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: textStyle]
        
        let textTextHeight: CGFloat = cellLabel.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        cellLabel.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
    }
    
    @objc public dynamic class func drawOnyxImageButton(frame: CGRect = CGRect(x: 0, y: -0, width: 200, height: 61), title: String = "Button", pressed: Bool = true, inset: CGFloat = 60, textWidth: CGFloat = 123, textHeight: CGFloat = 61) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Color Declarations
        let onyxButtonBackgroundStop1 = UIColor(red: 0.447, green: 0.447, blue: 0.447, alpha: 1.000)
        let onyxButtonBackgroundStop2 = UIColor(red: 0.373, green: 0.373, blue: 0.373, alpha: 1.000)
        let onyxButtonBackgroundStop3 = UIColor(red: 0.345, green: 0.345, blue: 0.345, alpha: 1.000)
        let onyxButtonLeftRightShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.100)
        let onyxButtonLeftRightShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.200)
        let onyxButtonTopShineColor5 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopTopShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let color = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.150)
        
        //// Gradient Declarations
        let onyxButtonBackground = CGGradient(colorsSpace: nil, colors: [onyxButtonBackgroundStop1.cgColor, onyxButtonBackgroundStop2.cgColor, onyxButtonBackgroundStop3.cgColor] as CFArray, locations: [0, 0.6, 1])!
        let onyxButtonRightShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor3.cgColor, onyxButtonLeftRightShineColor2.cgColor] as CFArray, locations: [0.98, 1])!
        let onyxButtonTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopShineColor5.cgColor, onyxButtonTopShineColor5.blended(withFraction: 0.5, of: onyxButtonTopShineColor3).cgColor, onyxButtonTopShineColor3.cgColor, onyxButtonTopShineColor.cgColor] as CFArray, locations: [0.85, 0.93, 0.98, 1])!
        let onyxButtonTopTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopTopShineColor2.cgColor, onyxButtonTopTopShineColor.cgColor] as CFArray, locations: [0.97, 1])!
        let onyxButtonLeftShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor2.cgColor, onyxButtonLeftRightShineColor3.cgColor] as CFArray, locations: [0, 0.02])!
        
        //// Shadow Declarations
        let buttonDropShadow = NSShadow()
        buttonDropShadow.shadowColor = UIColor.black.withAlphaComponent(0.3)
        buttonDropShadow.shadowOffset = CGSize(width: 0, height: 2)
        buttonDropShadow.shadowBlurRadius = 2
        
        //// Layer E Drawing
        context.saveGState()
        context.setAlpha(0.6)
        
        let layerEPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 1), cornerRadius: 5)
        UIColor.black.setFill()
        layerEPath.fill()
        
        context.restoreGState()
        
        
        //// Layer D Drawing
        let layerDRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1)
        let layerDPath = UIBezierPath(roundedRect: layerDRect, cornerRadius: 5)
        context.saveGState()
        context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        layerDPath.addClip()
        context.drawLinearGradient(onyxButtonBackground,
                                   start: CGPoint(x: layerDRect.midX, y: layerDRect.minY),
                                   end: CGPoint(x: layerDRect.midX, y: layerDRect.maxY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()
        
        
        
        //// Layer C RIght Drawing
        let layerCRIghtRect = CGRect(x: frame.minX + frame.width - 200, y: frame.minY, width: 200, height: frame.height - 1)
        let layerCRIghtPath = UIBezierPath(roundedRect: layerCRIghtRect, cornerRadius: 5)
        context.saveGState()
        layerCRIghtPath.addClip()
        context.drawLinearGradient(onyxButtonRightShine,
                                   start: CGPoint(x: layerCRIghtRect.minX, y: layerCRIghtRect.midY),
                                   end: CGPoint(x: layerCRIghtRect.maxX, y: layerCRIghtRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer C Left Drawing
        let layerCLeftRect = CGRect(x: frame.minX, y: frame.minY, width: 200, height: frame.height - 1)
        let layerCLeftPath = UIBezierPath(roundedRect: layerCLeftRect, cornerRadius: 5)
        context.saveGState()
        layerCLeftPath.addClip()
        context.drawLinearGradient(onyxButtonLeftShine,
                                   start: CGPoint(x: layerCLeftRect.minX, y: layerCLeftRect.midY),
                                   end: CGPoint(x: layerCLeftRect.maxX, y: layerCLeftRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer B Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerBRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerBPath = UIBezierPath(roundedRect: layerBRect, cornerRadius: 5)
        context.saveGState()
        layerBPath.addClip()
        context.drawLinearGradient(onyxButtonTopShine,
                                   start: CGPoint(x: layerBRect.midX, y: layerBRect.maxY),
                                   end: CGPoint(x: layerBRect.midX, y: layerBRect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        //// Layer A Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerARect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerAPath = UIBezierPath(roundedRect: layerARect, cornerRadius: 5)
        context.saveGState()
        layerAPath.addClip()
        context.drawLinearGradient(onyxButtonTopTopShine,
                                   start: CGPoint(x: layerARect.midX, y: layerARect.maxY),
                                   end: CGPoint(x: layerARect.midX, y: layerARect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        if (pressed) {
            //// Layer Pressed Overlay Drawing
            let layerPressedOverlayPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1), cornerRadius: 5)
            context.saveGState()
            context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
            color.setFill()
            layerPressedOverlayPath.fill()
            context.restoreGState()
            
        }
        
        
        //// Text Drawing
        //        let textRect = CGRect(x: inset + 5, y: 0, width: textWidth, height: textHeight)
        //        let textStyle = NSMutableParagraphStyle()
        //        textStyle.alignment = .left
        //        let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 19), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: textStyle]
        //
        //        let textTextHeight: CGFloat = title.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        //        context.saveGState()
        //        context.clip(to: textRect)
        //        title.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width - 10, height: textTextHeight), withAttributes: textFontAttributes)
        //        context.restoreGState()
    }
    
    @objc public dynamic class func drawOnyxImageButtonHolder(frame: CGRect = CGRect(x: 0, y: 0, width: 50, height: 50)) {
        //// Color Declarations
        let imageBg = UIColor(red: 0.314, green: 0.314, blue: 0.314, alpha: 1.000)
        let imageBgHighlight = UIColor(red: 0.545, green: 0.545, blue: 0.545, alpha: 1.000)
        let _08Black = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.900)
        
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 2), cornerRadius: 2)
        _08Black.setFill()
        rectangle2Path.fill()
        
        
        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 2, width: frame.width, height: frame.height - 2), cornerRadius: 2)
        imageBgHighlight.setFill()
        rectangle3Path.fill()
        
        
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 2), cornerRadius: 2)
        imageBg.setFill()
        rectanglePath.fill()
    }
    
    @objc public dynamic class func drawOnyxEmptyImageButtonHolder(frame: CGRect = CGRect(x: 0, y: 0, width: 50, height: 50)) {
        //// Color Declarations
        let imageBg = UIColor(red: 0.314, green: 0.314, blue: 0.314, alpha: 0.000)
        let imageBgHighlight = UIColor(red: 0.545, green: 0.545, blue: 0.545, alpha: 0.000)
        let _08Black = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.00)
        
        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 2), cornerRadius: 2)
        _08Black.setFill()
        rectangle2Path.fill()
        
        
        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 2, width: frame.width, height: frame.height - 2), cornerRadius: 2)
        imageBgHighlight.setFill()
        rectangle3Path.fill()
        
        
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 2), cornerRadius: 2)
        imageBg.setFill()
        rectanglePath.fill()
        
    }
    
    @objc public dynamic class func drawOnyxComboBoxButton(frame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 62), title: String = "", pressed: Bool = true, subtitle: String = "", offsetY: CGFloat = 36, offsetX: CGFloat = 178) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        //// Color Declarations
        let onyxButtonBackgroundStop1 = UIColor(red: 0.447, green: 0.447, blue: 0.447, alpha: 1.000)
        let onyxButtonBackgroundStop2 = UIColor(red: 0.373, green: 0.373, blue: 0.373, alpha: 1.000)
        let onyxButtonBackgroundStop3 = UIColor(red: 0.345, green: 0.345, blue: 0.345, alpha: 1.000)
        let onyxButtonLeftRightShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.100)
        let onyxButtonLeftRightShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.200)
        let onyxButtonTopShineColor5 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopTopShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let color = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.150)
        
        //// Gradient Declarations
        let onyxButtonBackground = CGGradient(colorsSpace: nil, colors: [onyxButtonBackgroundStop1.cgColor, onyxButtonBackgroundStop2.cgColor, onyxButtonBackgroundStop3.cgColor] as CFArray, locations: [0, 0.6, 1])!
        let onyxButtonRightShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor3.cgColor, onyxButtonLeftRightShineColor2.cgColor] as CFArray, locations: [0.98, 1])!
        let onyxButtonTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopShineColor5.cgColor, onyxButtonTopShineColor5.blended(withFraction: 0.5, of: onyxButtonTopShineColor3).cgColor, onyxButtonTopShineColor3.cgColor, onyxButtonTopShineColor.cgColor] as CFArray, locations: [0.85, 0.93, 0.98, 1])!
        let onyxButtonTopTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopTopShineColor2.cgColor, onyxButtonTopTopShineColor.cgColor] as CFArray, locations: [0.97, 1])!
        let onyxButtonLeftShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor2.cgColor, onyxButtonLeftRightShineColor3.cgColor] as CFArray, locations: [0, 0.02])!
        
        //// Shadow Declarations
        let buttonDropShadow = NSShadow()
        buttonDropShadow.shadowColor = UIColor.black.withAlphaComponent(0.3)
        buttonDropShadow.shadowOffset = CGSize(width: 0, height: 2)
        buttonDropShadow.shadowBlurRadius = 2
        
        
        //// Subframes
        let frame2 = CGRect(x: frame.minX + fastFloor((frame.width - 15) * 0.00000 + 0.5), y: frame.minY + 1, width: frame.width - 15 - fastFloor((frame.width - 15) * 0.00000 + 0.5), height: frame.height - 2)
        
        
        //// Layer E Drawing
        context.saveGState()
        context.setAlpha(0.6)
        
        let layerEPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 2), cornerRadius: 3)
        UIColor.black.setFill()
        layerEPath.fill()
        
        context.restoreGState()
        
        
        //// Layer D Drawing
        let layerDRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1)
        let layerDPath = UIBezierPath(roundedRect: layerDRect, cornerRadius: 3)
        context.saveGState()
        context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        layerDPath.addClip()
        context.drawLinearGradient(onyxButtonBackground,
                                   start: CGPoint(x: layerDRect.midX, y: layerDRect.minY),
                                   end: CGPoint(x: layerDRect.midX, y: layerDRect.maxY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()
        
        
        
        //// Layer C RIght Drawing
        let layerCRIghtRect = CGRect(x: frame.minX + frame.width - 200, y: frame.minY, width: 200, height: frame.height - 1)
        let layerCRIghtPath = UIBezierPath(roundedRect: layerCRIghtRect, cornerRadius: 3)
        context.saveGState()
        layerCRIghtPath.addClip()
        context.drawLinearGradient(onyxButtonRightShine,
                                   start: CGPoint(x: layerCRIghtRect.minX, y: layerCRIghtRect.midY),
                                   end: CGPoint(x: layerCRIghtRect.maxX, y: layerCRIghtRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer C Left Drawing
        let layerCLeftRect = CGRect(x: frame.minX, y: frame.minY, width: 200, height: frame.height - 1)
        let layerCLeftPath = UIBezierPath(roundedRect: layerCLeftRect, cornerRadius: 3)
        context.saveGState()
        layerCLeftPath.addClip()
        context.drawLinearGradient(onyxButtonLeftShine,
                                   start: CGPoint(x: layerCLeftRect.minX, y: layerCLeftRect.midY),
                                   end: CGPoint(x: layerCLeftRect.maxX, y: layerCLeftRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer B Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerBRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerBPath = UIBezierPath(roundedRect: layerBRect, cornerRadius: 3)
        context.saveGState()
        layerBPath.addClip()
        context.drawLinearGradient(onyxButtonTopShine,
                                   start: CGPoint(x: layerBRect.midX, y: layerBRect.maxY),
                                   end: CGPoint(x: layerBRect.midX, y: layerBRect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        //// Layer A Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerARect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerAPath = UIBezierPath(roundedRect: layerARect, cornerRadius: 3)
        context.saveGState()
        layerAPath.addClip()
        context.drawLinearGradient(onyxButtonTopTopShine,
                                   start: CGPoint(x: layerARect.midX, y: layerARect.maxY),
                                   end: CGPoint(x: layerARect.midX, y: layerARect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        if (pressed) {
            //// Layer Pressed Overlay Drawing
            let layerPressedOverlayPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1), cornerRadius: 3)
            context.saveGState()
            context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
            color.setFill()
            layerPressedOverlayPath.fill()
            context.restoreGState()
            
        }
        
        
        //// Text Drawing
        let textRect = CGRect(x: frame2.minX + 8, y: frame2.minY + 12, width: fastFloor((frame2.width - 8) * 1.00000 + 0.5), height: frame2.height - 39)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: UIFont.smallSystemFontSize), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: textStyle]
        
        let textTextHeight: CGFloat = title.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        title.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        
        //// Text 2 Drawing
        let text2Rect = CGRect(x: frame2.minX + 8, y: frame2.minY + 26, width: fastFloor((frame2.width - 8) * 1.00000 + 0.5), height: frame2.height - 39)
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .left
        let text2FontAttributes = [NSAttributedString.Key.font: UIFont.italicSystemFont(ofSize: UIFont.smallSystemFontSize), NSAttributedString.Key.foregroundColor: UIColor.white, NSAttributedString.Key.paragraphStyle: text2Style]
        
        let text2TextHeight: CGFloat = subtitle.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        subtitle.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        
        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: offsetX, y: offsetY)
        
        let symbolRect = CGRect(x: 0, y: -9, width: 12, height: 9)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        
        SalesConfigControls.drawCanvas1(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch)
        context.restoreGState()
        
        context.restoreGState()
    }
    
    //TO DO Change drawOnyxComboBoxButton method provided, as it has issue with text rendering so using UIButton setTitle Property
    
    @objc public dynamic class func drawOnyxComboBoxDev(frame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 62), pressed: Bool = true, offsetY: CGFloat = 36, offsetX: CGFloat = 178) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        //// Color Declarations
        let onyxButtonBackgroundStop1 = UIColor(red: 0.447, green: 0.447, blue: 0.447, alpha: 1.000)
        let onyxButtonBackgroundStop2 = UIColor(red: 0.373, green: 0.373, blue: 0.373, alpha: 1.000)
        let onyxButtonBackgroundStop3 = UIColor(red: 0.345, green: 0.345, blue: 0.345, alpha: 1.000)
        let onyxButtonLeftRightShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.100)
        let onyxButtonLeftRightShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopShineColor3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.200)
        let onyxButtonTopShineColor5 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let onyxButtonTopTopShineColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.400)
        let onyxButtonTopTopShineColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let color = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.150)
        
        //// Gradient Declarations
        let onyxButtonBackground = CGGradient(colorsSpace: nil, colors: [onyxButtonBackgroundStop1.cgColor, onyxButtonBackgroundStop2.cgColor, onyxButtonBackgroundStop3.cgColor] as CFArray, locations: [0, 0.6, 1])!
        let onyxButtonRightShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor3.cgColor, onyxButtonLeftRightShineColor2.cgColor] as CFArray, locations: [0.98, 1])!
        let onyxButtonTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopShineColor5.cgColor, onyxButtonTopShineColor5.blended(withFraction: 0.5, of: onyxButtonTopShineColor3).cgColor, onyxButtonTopShineColor3.cgColor, onyxButtonTopShineColor.cgColor] as CFArray, locations: [0.85, 0.93, 0.98, 1])!
        let onyxButtonTopTopShine = CGGradient(colorsSpace: nil, colors: [onyxButtonTopTopShineColor2.cgColor, onyxButtonTopTopShineColor.cgColor] as CFArray, locations: [0.97, 1])!
        let onyxButtonLeftShine = CGGradient(colorsSpace: nil, colors: [onyxButtonLeftRightShineColor2.cgColor, onyxButtonLeftRightShineColor3.cgColor] as CFArray, locations: [0, 0.02])!
        
        //// Shadow Declarations
        let buttonDropShadow = NSShadow()
        buttonDropShadow.shadowColor = UIColor.black.withAlphaComponent(0.3)
        buttonDropShadow.shadowOffset = CGSize(width: 0, height: 2)
        buttonDropShadow.shadowBlurRadius = 2
        
        
        //// Subframes
        //        let frame2 = CGRect(x: frame.minX + fastFloor((frame.width - 15) * 0.00000 + 0.5), y: frame.minY + 1, width: frame.width - 15 - fastFloor((frame.width - 15) * 0.00000 + 0.5), height: frame.height - 2)
        
        
        //// Layer E Drawing
        context.saveGState()
        context.setAlpha(0.6)
        
        let layerEPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY + 1, width: frame.width, height: frame.height - 2), cornerRadius: 3)
        UIColor.black.setFill()
        layerEPath.fill()
        
        context.restoreGState()
        
        
        //// Layer D Drawing
        let layerDRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1)
        let layerDPath = UIBezierPath(roundedRect: layerDRect, cornerRadius: 3)
        context.saveGState()
        context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        layerDPath.addClip()
        context.drawLinearGradient(onyxButtonBackground,
                                   start: CGPoint(x: layerDRect.midX, y: layerDRect.minY),
                                   end: CGPoint(x: layerDRect.midX, y: layerDRect.maxY),
                                   options: [])
        context.endTransparencyLayer()
        context.restoreGState()
        
        
        
        //// Layer C RIght Drawing
        let layerCRIghtRect = CGRect(x: frame.minX + frame.width - 200, y: frame.minY, width: 200, height: frame.height - 1)
        let layerCRIghtPath = UIBezierPath(roundedRect: layerCRIghtRect, cornerRadius: 3)
        context.saveGState()
        layerCRIghtPath.addClip()
        context.drawLinearGradient(onyxButtonRightShine,
                                   start: CGPoint(x: layerCRIghtRect.minX, y: layerCRIghtRect.midY),
                                   end: CGPoint(x: layerCRIghtRect.maxX, y: layerCRIghtRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer C Left Drawing
        let layerCLeftRect = CGRect(x: frame.minX, y: frame.minY, width: 200, height: frame.height - 1)
        let layerCLeftPath = UIBezierPath(roundedRect: layerCLeftRect, cornerRadius: 3)
        context.saveGState()
        layerCLeftPath.addClip()
        context.drawLinearGradient(onyxButtonLeftShine,
                                   start: CGPoint(x: layerCLeftRect.minX, y: layerCLeftRect.midY),
                                   end: CGPoint(x: layerCLeftRect.maxX, y: layerCLeftRect.midY),
                                   options: [])
        context.restoreGState()
        
        
        //// Layer B Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerBRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerBPath = UIBezierPath(roundedRect: layerBRect, cornerRadius: 3)
        context.saveGState()
        layerBPath.addClip()
        context.drawLinearGradient(onyxButtonTopShine,
                                   start: CGPoint(x: layerBRect.midX, y: layerBRect.maxY),
                                   end: CGPoint(x: layerBRect.midX, y: layerBRect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        //// Layer A Drawing
        context.saveGState()
        context.setAlpha(0.7)
        
        let layerARect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: 60)
        let layerAPath = UIBezierPath(roundedRect: layerARect, cornerRadius: 3)
        context.saveGState()
        layerAPath.addClip()
        context.drawLinearGradient(onyxButtonTopTopShine,
                                   start: CGPoint(x: layerARect.midX, y: layerARect.maxY),
                                   end: CGPoint(x: layerARect.midX, y: layerARect.minY),
                                   options: [])
        context.restoreGState()
        
        context.restoreGState()
        
        
        if (pressed) {
            //// Layer Pressed Overlay Drawing
            let layerPressedOverlayPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height - 1), cornerRadius: 3)
            context.saveGState()
            context.setShadow(offset: buttonDropShadow.shadowOffset, blur: buttonDropShadow.shadowBlurRadius, color: (buttonDropShadow.shadowColor as! UIColor).cgColor)
            color.setFill()
            layerPressedOverlayPath.fill()
            context.restoreGState()
            
        }
        
        /*
         //// Text Drawing
         let textRect = CGRect(x: frame2.minX + 28, y: frame2.minY + 32, width: fastFloor((frame2.width - 8) * 1.00000 + 0.5), height: frame2.height - 39)
         let textStyle = NSMutableParagraphStyle()
         textStyle.alignment = .left
         let textFontAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: UIFont.smallSystemFontSize), NSForegroundColorAttributeName: UIColor.white, NSAttributedString.Key.paragraphStyle: textStyle]
         
         let textTextHeight: CGFloat = title.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
         context.saveGState()
         context.clip(to: textRect)
         title.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
         context.restoreGState()
         
         
         //// Text 2 Drawing
         let text2Rect = CGRect(x: frame2.minX + 8, y: frame2.minY + 26, width: fastFloor((frame2.width - 8) * 1.00000 + 0.5), height: frame2.height - 39)
         let text2Style = NSMutableParagraphStyle()
         text2Style.alignment = .left
         let text2FontAttributes = [NSAttributedString.Key.font: UIFont.italicSystemFont(ofSize: UIFont.smallSystemFontSize), NSForegroundColorAttributeName: UIColor.white, NSAttributedString.Key.paragraphStyle: text2Style]
         
         let text2TextHeight: CGFloat = subtitle.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
         context.saveGState()
         context.clip(to: text2Rect)
         subtitle.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
         context.restoreGState()
         */
        
        
        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: offsetX, y: offsetY)
        
        let symbolRect = CGRect(x: 0, y: -9, width: 12, height: 9)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        
        SalesConfigControls.drawCanvas1(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch)
        
        context.restoreGState()
        
        context.restoreGState()
    }
    
    @objc public dynamic class func drawCanvas1(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 13, height: 9), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 13, height: 9), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 13, y: resizedFrame.height / 9)
        
        
        //// Polygon Drawing
        context.saveGState()
        context.translateBy(x: 6.06, y: 3)
        context.rotate(by: -180 * CGFloat.pi/180)
        
        let polygonPath = UIBezierPath()
        polygonPath.move(to: CGPoint(x: 0, y: -6))
        polygonPath.addLine(to: CGPoint(x: 6.06, y: 3))
        polygonPath.addLine(to: CGPoint(x: -6.06, y: 3))
        polygonPath.close()
        UIColor.white.setFill()
        polygonPath.fill()
        
        context.restoreGState()
        
        context.restoreGState()
        
    }
    
    
    
    
    @objc(SalesConfigControlsResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.
        
        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }
            
            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)
            
            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }
            
            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1
        
        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)
        
        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
                       green: g1 * (1 - fraction) + g2 * fraction,
                       blue: b1 * (1 - fraction) + b2 * fraction,
                       alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}
